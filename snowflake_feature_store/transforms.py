"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_transforms.ipynb.

# %% ../nbs/02_transforms.ipynb 2
from __future__ import annotations
from typing import Union, List, Callable, Optional, Protocol, Dict
from dataclasses import dataclass
from fastcore.basics import listify
import snowflake.snowpark.functions as F
from snowflake.snowpark import DataFrame, Window

# %% auto 0
__all__ = ['Transform', 'WindowSpec', 'window_agg', 'fill_na', 'date_diff', 'moving_agg', 'cumulative_agg', 'apply_transforms']

# %% ../nbs/02_transforms.ipynb 3
class Transform(Protocol):
    "Protocol for feature transformations"
    def __call__(self, df: DataFrame) -> DataFrame: ...

# %% ../nbs/02_transforms.ipynb 5
@dataclass
class WindowSpec:
    "Configuration for window-based transformations"
    partition_by: Optional[Union[str, List[str]]] = None
    order_by: Optional[Union[str, List[str]]] = None
    window_size: Optional[int] = None
    
    def __post_init__(self):
        "Convert string inputs to lists"
        if isinstance(self.partition_by, str):
            self.partition_by = [self.partition_by]
        if isinstance(self.order_by, str):
            self.order_by = [self.order_by]
            
    def to_window(self) -> Window:
        "Convert to Snowpark Window specification"
        window = Window.partition_by(self.partition_by or []) \
                      .order_by(self.order_by or [])
        
        if self.window_size:
            window = window.rows_between(
                -(self.window_size-1),
                Window.CURRENT_ROW
            )
        return window


# %% ../nbs/02_transforms.ipynb 6
def window_agg(
    agg_cols: Dict[str, List[str]],
    window_spec: WindowSpec
) -> Transform:
    """Apply window-based aggregations
    
    Args:
        agg_cols: Dictionary mapping columns to aggregation functions
        window_spec: Window specification for the aggregation
        
    Returns:
        Transform function
        
    Example:
        >>> spec = WindowSpec(partition_by='customer_id', order_by='date')
        >>> aggs = {'amount': ['SUM', 'AVG']}
        >>> window_agg(aggs, spec)(df)
    """
    def _inner(df: DataFrame) -> DataFrame:
        # Use the WindowSpec's to_window method
        window = window_spec.to_window()
            
        for col, aggs in agg_cols.items():
            for agg in aggs:
                agg_func = getattr(F, agg.lower())
                # Snowflake typically uppercases column names
                new_col = f"{agg.upper()}_{col.upper()}"
                df = df.with_column(
                    new_col,
                    agg_func(F.col(col)).over(window)
                )
        return df
    return _inner

# %% ../nbs/02_transforms.ipynb 8
def fill_na(cols: Union[str, List[str]], fill_value: Union[int, float, str] = 0) -> Transform:
    """Fill NA values in specified columns, matching the column type
    
    Args:
        cols: Column(s) to fill NA values in
        fill_value: Value to use for filling NAs (will be cast to match column type)
        
    Returns:
        Transform function
        
    Example:
        >>> df = session.create_dataframe([[1, None], [2, 3]], ['A', 'B'])
        >>> fill_na('B', 0)(df).collect()
        [[1, 0], [2, 3]]
    """
    cols = listify(cols)
    def _inner(df: DataFrame) -> DataFrame:
        for col in cols:
            # Find actual column name (case-insensitive)
            actual_col = next(
                (c for c in df.schema.names if c.upper() == col.upper()),
                None
            )
            if actual_col is None:
                raise ValueError(f"Column {col} not found in DataFrame")
            
            # Get column type
            col_type = df.schema[actual_col].datatype
            
            # Cast fill value to match column type
            typed_value = (
                int(fill_value) if str(col_type).startswith(('Long', 'Int')) 
                else float(fill_value) if str(col_type).startswith('Double') 
                else str(fill_value)
            )
            
            df = df.na.fill({actual_col: typed_value})
        return df
    return _inner


# %% ../nbs/02_transforms.ipynb 10
def date_diff(
    col: str,
    new_col: str,
    reference_date: Optional[str] = None,
    date_part: str = 'day'
) -> Transform:
    """Calculate date difference between column and reference
    
    Args:
        col: Date column to calculate difference from
        new_col: Name for the new difference column
        reference_date: Reference date (default: current_date)
        date_part: Part to calculate difference in ('day', 'month', etc.)
        
    Returns:
        Transform function
        
    Example:
        >>> df = session.create_dataframe([['2024-01-01']], ['date'])
        >>> date_diff('date', 'days_ago', '2024-02-01')(df).collect()
        [['2024-01-01', 31]]
    """
    def _inner(df: DataFrame) -> DataFrame:
        # Ensure column exists (case-insensitive)
        col_actual = [c for c in df.columns if c.upper() == col.upper()][0]
        
        reference = (F.to_date(F.lit(reference_date)) 
                    if isinstance(reference_date, str)
                    else F.current_date())
        
        return df.with_column(
            new_col.upper(),  # Standardize output column name
            F.datediff(date_part, F.col(col_actual), reference)
        )
    return _inner

# %% ../nbs/02_transforms.ipynb 12
def moving_agg(
    cols: Union[str, List[str]],
    window_sizes: List[int],
    agg_funcs: List[str] = ['SUM', 'AVG'],
    partition_by: Optional[List[str]] = None,
    order_by: Optional[List[str]] = None
) -> Transform:
    """Calculate moving window aggregations
    
    Args:
        cols: Columns to aggregate
        window_sizes: List of window sizes
        agg_funcs: List of aggregation functions
        partition_by: Columns to partition by
        order_by: Columns to order by
        
    Returns:
        Transform function
        
    Example:
        >>> moving_agg('amount', [3, 7], ['SUM'], ['customer_id'], ['date'])(df)
    """
    cols = listify(cols)
    def _inner(df: DataFrame) -> DataFrame:
        for col in cols:
            for size in window_sizes:
                spec = WindowSpec(
                    partition_by=partition_by,
                    order_by=order_by,
                    window_size=size
                )
                aggs = {col: agg_funcs}
                df = window_agg(aggs, spec)(df)
        return df
    return _inner


# %% ../nbs/02_transforms.ipynb 13
def cumulative_agg(
    cols: Union[str, List[str]],
    agg_funcs: List[str] = ['SUM'],
    partition_by: Optional[List[str]] = None,
    order_by: Optional[List[str]] = None
) -> Transform:
    """Calculate cumulative aggregations
    
    Args:
        cols: Columns to aggregate
        agg_funcs: List of aggregation functions
        partition_by: Columns to partition by
        order_by: Columns to order by
        
    Returns:
        Transform function
        
    Example:
        >>> cumulative_agg('amount', ['SUM'], ['customer_id'], ['date'])(df)
    """
    return moving_agg(
        cols=cols,
        window_sizes=[None],  # None means unbounded
        agg_funcs=agg_funcs,
        partition_by=partition_by,
        order_by=order_by
    )

# %% ../nbs/02_transforms.ipynb 14
def apply_transforms(df: DataFrame, transforms: List[Transform]) -> DataFrame:
    """Apply a list of transformations to a DataFrame
    
    Args:
        df: Input DataFrame
        transforms: List of transform functions to apply
        
    Returns:
        Transformed DataFrame
        
    Example:
        >>> transforms = [
        ...     fill_na(['score']),
        ...     date_diff('date', 'days_ago')
        ... ]
        >>> apply_transforms(df, transforms)
    """
    for transform in transforms:
        df = transform(df)
    return df

