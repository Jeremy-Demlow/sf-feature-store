"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_manager.ipynb.

# %% ../nbs/04_manager.ipynb 2
from __future__ import annotations
from typing import List, Optional, Dict, Union, Protocol, Callable
from dataclasses import dataclass
import uuid
from contextlib import contextmanager
from typing import Optional

from snowflake.ml.feature_store import FeatureStore, Entity, FeatureView, CreationMode
from snowflake.snowpark import DataFrame

from .connection import SnowflakeConnection
from .feature_view import FeatureViewConfig, create_feature_view
from .transforms import Transform, apply_transforms
from datetime import datetime, timezone 


# %% auto 0
__all__ = ['FeatureStoreCallback', 'PrintCallback', 'FeatureStoreManager', 'feature_store_session']

# %% ../nbs/04_manager.ipynb 3
class FeatureStoreCallback(Protocol):
    "Protocol for feature store callbacks"
    def on_feature_view_create(self, name: str, df: DataFrame) -> None: ...
    def on_entity_create(self, name: str, keys: List[str]) -> None: ...
    def on_error(self, error: str) -> None: ...


# %% ../nbs/04_manager.ipynb 4
class PrintCallback:
    "Simple callback that prints events"
    def on_feature_view_create(self, name: str, df: DataFrame) -> None:
        print(f"Created feature view: {name} with {len(df.columns)} features")
    
    def on_entity_create(self, name: str, keys: List[str]) -> None:
        print(f"Created entity: {name} with keys: {keys}")
        
    def on_error(self, error: str) -> None:
        print(f"Error: {error}")


# %% ../nbs/04_manager.ipynb 5
@dataclass
class FeatureStoreManager:
    """Manages feature store operations
    
    Args:
        connection: Snowflake connection
        callbacks: Optional callbacks for monitoring
        overwrite: Whether to overwrite existing features
    """
    connection: SnowflakeConnection
    callbacks: List[FeatureStoreCallback] = None
    overwrite: bool = False
    
    def __post_init__(self):
        "Initialize feature store"
        self.feature_store = FeatureStore(
            session=self.connection.session,
            database=self.connection.database,
            name=self.connection.schema,
            default_warehouse=self.connection.warehouse,
            creation_mode=CreationMode.CREATE_IF_NOT_EXIST
        )
        self.entities: Dict[str, Entity] = {}
        self.feature_views: Dict[str, FeatureView] = {}
        self.callbacks = self.callbacks or []
        
    def add_entity(self, 
                  name: str, 
                  join_keys: List[str], 
                  description: Optional[str] = None) -> FeatureStoreManager:
        """Add entity to feature store
        
        Args:
            name: Entity name
            join_keys: Keys used for joining
            description: Optional description
            
        Returns:
            Self for method chaining
        """
        entity = Entity(
            name=name,
            join_keys=join_keys,
            desc=description or f"Entity {name}"
        )
        try:
            self.feature_store.register_entity(entity)
            self.entities[name] = entity
            for cb in self.callbacks:
                cb.on_entity_create(name, join_keys)
        except Exception as e:
            for cb in self.callbacks:
                cb.on_error(f"Error creating entity {name}: {str(e)}")
            raise
        return self
    
    def add_feature_view(self,
                        config: FeatureViewConfig,
                        df: DataFrame,
                        entity_name: str,
                        transforms: Optional[List[Transform]] = None) -> FeatureView:
        """Add feature view to feature store"""
        try:
            # Validate schema only (no execution)
            self._validate_schema_only(df)
            
            # Apply transforms if provided
            if transforms:
                df = apply_transforms(df, transforms)
            
            self._validate_sql(df)
                
            # Get entity
            entity = self.entities.get(entity_name)
            if not entity:
                raise ValueError(f"Entity {entity_name} not found")
                
            # Create feature view
            feature_view = create_feature_view(config, df, entity)
            
            # Register feature view (this is where actual execution happens)
            registered_view = self.feature_store.register_feature_view(
                feature_view=feature_view,
                version=config.version,
                block=True,
                overwrite=self.overwrite
            )
            
            # Store for later reference
            self.feature_views[config.full_name] = registered_view
            
            # Notify callbacks
            for cb in self.callbacks:
                cb.on_feature_view_create(config.full_name, df)
                
            return registered_view
            
        except Exception as e:
            for cb in self.callbacks:
                cb.on_error(f"Error creating feature view {config.full_name}: {str(e)}")
            raise

    def get_features(self,
                    spine_df: DataFrame,
                    feature_views: List[Union[str, FeatureViewConfig]],
                    label_cols: Optional[List[str]] = None,
                    dataset_name: Optional[str] = None,
                    spine_timestamp_col: Optional[str] = None,
                    **kwargs) -> DataFrame:
        """Get features for training or inference"""
        views = []
        for fv in feature_views:
            if isinstance(fv, FeatureViewConfig):
                view = self.feature_store.get_feature_view(
                    fv.full_name, 
                    version=fv.version
                )
            else:
                name, version = fv.split('/')
                view = self.feature_store.get_feature_view(name, version)
            views.append(view)
        
        if dataset_name is None:
            # Use datetime.now() with timezone
            timestamp = datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')
            unique_id = str(uuid.uuid4())[:8]
            dataset_name = f"DATASET_{timestamp}_{unique_id}"
        
        dataset = self.feature_store.generate_dataset(
            name=dataset_name,
            spine_df=spine_df,
            features=views,
            spine_label_cols=label_cols,
            spine_timestamp_col=spine_timestamp_col,
            **kwargs
        )
        
        return dataset.read.to_snowpark_dataframe()

    
    def _validate_sql(self, df: DataFrame) -> None:
        """Validate the SQL that will be generated
        
        Args:
            df: DataFrame to validate
            
        Raises:
            ValueError: If SQL validation fails
        """
        try:
            # Get the SQL query
            sql = df.queries['queries'][0]
            
            # Try executing the query with LIMIT 0 to validate syntax
            test_sql = f"SELECT * FROM ({sql}) LIMIT 0"
            self.connection.session.sql(test_sql).collect()
            
        except Exception as e:
            for cb in self.callbacks:
                cb.on_error(f"SQL validation failed: {str(e)}")
            raise ValueError(f"SQL validation failed: {str(e)}")
        
    def _validate_schema_only(self, df: DataFrame) -> None:
        """Validate DataFrame schema without triggering execution"""
        try:
            from snowflake.snowpark.types import (
                StringType, IntegerType, FloatType, LongType, 
                DateType, TimestampType, DoubleType, BooleanType
            )
            
            valid_types = {
                type(StringType()): 'string',
                type(IntegerType()): 'integer',
                type(FloatType()): 'float',
                type(LongType()): 'long',
                type(DateType()): 'date',
                type(TimestampType()): 'timestamp',
                type(DoubleType()): 'double',
                type(BooleanType()): 'boolean'
            }
            
            schema = df.schema
            if not schema:
                raise ValueError("DataFrame has no schema")
                
            for field in schema.fields:
                field_type = type(field.datatype)
                if field_type not in valid_types:
                    raise ValueError(
                        f"Unsupported data type for field {field.name}: "
                        f"{field.datatype} (type: {field_type})"
                    )
                        
        except Exception as e:
            for cb in self.callbacks:
                cb.on_error(f"Schema validation failed: {str(e)}")
            raise ValueError(f"Schema validation failed: {str(e)}")



# %% ../nbs/04_manager.ipynb 6
@contextmanager
def feature_store_session(connection: SnowflakeConnection, 
                         schema_name: Optional[str] = None,
                         cleanup: bool = True):
    """Context manager for feature store operations"""
    schema = schema_name or f"FEATURE_STORE_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:8]}"
    original_schema = connection.schema
    
    try:
        # Create schema
        connection.session.sql(f"CREATE SCHEMA IF NOT EXISTS {connection.database}.{schema}").collect()
        
        # Set the schema as current
        connection.session.sql(f"USE SCHEMA {connection.database}.{schema}").collect()
        connection.schema = schema
        
        # Create and yield manager
        manager = FeatureStoreManager(
            connection=connection,
            callbacks=[PrintCallback()],
            overwrite=True
        )
        yield manager
        
    finally:
        if cleanup:
            try:
                # Cleanup schema and all objects
                connection.session.sql(f"DROP SCHEMA IF EXISTS {connection.database}.{schema} CASCADE").collect()
            except Exception as e:
                print(f"Cleanup failed: {str(e)}")
            
            # Restore original schema
            try:
                connection.session.sql(f"USE SCHEMA {connection.database}.{original_schema}").collect()
                connection.schema = original_schema
            except Exception as e:
                print(f"Failed to restore original schema: {str(e)}")

